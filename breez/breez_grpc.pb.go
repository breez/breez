// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.28.3
// source: breez.proto

package breez

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InvoicerClient is the client API for Invoicer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InvoicerClient interface {
	RegisterDevice(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error)
	SendInvoice(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*InvoiceReply, error)
}

type invoicerClient struct {
	cc grpc.ClientConnInterface
}

func NewInvoicerClient(cc grpc.ClientConnInterface) InvoicerClient {
	return &invoicerClient{cc}
}

func (c *invoicerClient) RegisterDevice(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error) {
	out := new(RegisterReply)
	err := c.cc.Invoke(ctx, "/breez.Invoicer/RegisterDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoicerClient) SendInvoice(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*InvoiceReply, error) {
	out := new(InvoiceReply)
	err := c.cc.Invoke(ctx, "/breez.Invoicer/SendInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InvoicerServer is the server API for Invoicer service.
// All implementations must embed UnimplementedInvoicerServer
// for forward compatibility
type InvoicerServer interface {
	RegisterDevice(context.Context, *RegisterRequest) (*RegisterReply, error)
	SendInvoice(context.Context, *PaymentRequest) (*InvoiceReply, error)
	mustEmbedUnimplementedInvoicerServer()
}

// UnimplementedInvoicerServer must be embedded to have forward compatible implementations.
type UnimplementedInvoicerServer struct {
}

func (UnimplementedInvoicerServer) RegisterDevice(context.Context, *RegisterRequest) (*RegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedInvoicerServer) SendInvoice(context.Context, *PaymentRequest) (*InvoiceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendInvoice not implemented")
}
func (UnimplementedInvoicerServer) mustEmbedUnimplementedInvoicerServer() {}

// UnsafeInvoicerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InvoicerServer will
// result in compilation errors.
type UnsafeInvoicerServer interface {
	mustEmbedUnimplementedInvoicerServer()
}

func RegisterInvoicerServer(s grpc.ServiceRegistrar, srv InvoicerServer) {
	s.RegisterService(&Invoicer_ServiceDesc, srv)
}

func _Invoicer_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicerServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Invoicer/RegisterDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicerServer).RegisterDevice(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Invoicer_SendInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoicerServer).SendInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Invoicer/SendInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoicerServer).SendInvoice(ctx, req.(*PaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Invoicer_ServiceDesc is the grpc.ServiceDesc for Invoicer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Invoicer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.Invoicer",
	HandlerType: (*InvoicerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDevice",
			Handler:    _Invoicer_RegisterDevice_Handler,
		},
		{
			MethodName: "SendInvoice",
			Handler:    _Invoicer_SendInvoice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// CardOrdererClient is the client API for CardOrderer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CardOrdererClient interface {
	Order(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderReply, error)
}

type cardOrdererClient struct {
	cc grpc.ClientConnInterface
}

func NewCardOrdererClient(cc grpc.ClientConnInterface) CardOrdererClient {
	return &cardOrdererClient{cc}
}

func (c *cardOrdererClient) Order(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderReply, error) {
	out := new(OrderReply)
	err := c.cc.Invoke(ctx, "/breez.CardOrderer/Order", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CardOrdererServer is the server API for CardOrderer service.
// All implementations must embed UnimplementedCardOrdererServer
// for forward compatibility
type CardOrdererServer interface {
	Order(context.Context, *OrderRequest) (*OrderReply, error)
	mustEmbedUnimplementedCardOrdererServer()
}

// UnimplementedCardOrdererServer must be embedded to have forward compatible implementations.
type UnimplementedCardOrdererServer struct {
}

func (UnimplementedCardOrdererServer) Order(context.Context, *OrderRequest) (*OrderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Order not implemented")
}
func (UnimplementedCardOrdererServer) mustEmbedUnimplementedCardOrdererServer() {}

// UnsafeCardOrdererServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CardOrdererServer will
// result in compilation errors.
type UnsafeCardOrdererServer interface {
	mustEmbedUnimplementedCardOrdererServer()
}

func RegisterCardOrdererServer(s grpc.ServiceRegistrar, srv CardOrdererServer) {
	s.RegisterService(&CardOrderer_ServiceDesc, srv)
}

func _CardOrderer_Order_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CardOrdererServer).Order(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.CardOrderer/Order",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CardOrdererServer).Order(ctx, req.(*OrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CardOrderer_ServiceDesc is the grpc.ServiceDesc for CardOrderer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CardOrderer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.CardOrderer",
	HandlerType: (*CardOrdererServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Order",
			Handler:    _CardOrderer_Order_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// PosClient is the client API for Pos service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PosClient interface {
	RegisterDevice(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error)
	UploadLogo(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileReply, error)
}

type posClient struct {
	cc grpc.ClientConnInterface
}

func NewPosClient(cc grpc.ClientConnInterface) PosClient {
	return &posClient{cc}
}

func (c *posClient) RegisterDevice(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error) {
	out := new(RegisterReply)
	err := c.cc.Invoke(ctx, "/breez.Pos/RegisterDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *posClient) UploadLogo(ctx context.Context, in *UploadFileRequest, opts ...grpc.CallOption) (*UploadFileReply, error) {
	out := new(UploadFileReply)
	err := c.cc.Invoke(ctx, "/breez.Pos/UploadLogo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PosServer is the server API for Pos service.
// All implementations must embed UnimplementedPosServer
// for forward compatibility
type PosServer interface {
	RegisterDevice(context.Context, *RegisterRequest) (*RegisterReply, error)
	UploadLogo(context.Context, *UploadFileRequest) (*UploadFileReply, error)
	mustEmbedUnimplementedPosServer()
}

// UnimplementedPosServer must be embedded to have forward compatible implementations.
type UnimplementedPosServer struct {
}

func (UnimplementedPosServer) RegisterDevice(context.Context, *RegisterRequest) (*RegisterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedPosServer) UploadLogo(context.Context, *UploadFileRequest) (*UploadFileReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadLogo not implemented")
}
func (UnimplementedPosServer) mustEmbedUnimplementedPosServer() {}

// UnsafePosServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PosServer will
// result in compilation errors.
type UnsafePosServer interface {
	mustEmbedUnimplementedPosServer()
}

func RegisterPosServer(s grpc.ServiceRegistrar, srv PosServer) {
	s.RegisterService(&Pos_ServiceDesc, srv)
}

func _Pos_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PosServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Pos/RegisterDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PosServer).RegisterDevice(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pos_UploadLogo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PosServer).UploadLogo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Pos/UploadLogo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PosServer).UploadLogo(ctx, req.(*UploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Pos_ServiceDesc is the grpc.ServiceDesc for Pos service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Pos_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.Pos",
	HandlerType: (*PosServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDevice",
			Handler:    _Pos_RegisterDevice_Handler,
		},
		{
			MethodName: "UploadLogo",
			Handler:    _Pos_UploadLogo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// InformationClient is the client API for Information service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InformationClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
	Rates(ctx context.Context, in *RatesRequest, opts ...grpc.CallOption) (*RatesReply, error)
	BreezAppVersions(ctx context.Context, in *BreezAppVersionsRequest, opts ...grpc.CallOption) (*BreezAppVersionsReply, error)
	ReceiverInfo(ctx context.Context, in *ReceiverInfoRequest, opts ...grpc.CallOption) (*ReceiverInfoReply, error)
}

type informationClient struct {
	cc grpc.ClientConnInterface
}

func NewInformationClient(cc grpc.ClientConnInterface) InformationClient {
	return &informationClient{cc}
}

func (c *informationClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := c.cc.Invoke(ctx, "/breez.Information/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *informationClient) Rates(ctx context.Context, in *RatesRequest, opts ...grpc.CallOption) (*RatesReply, error) {
	out := new(RatesReply)
	err := c.cc.Invoke(ctx, "/breez.Information/Rates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *informationClient) BreezAppVersions(ctx context.Context, in *BreezAppVersionsRequest, opts ...grpc.CallOption) (*BreezAppVersionsReply, error) {
	out := new(BreezAppVersionsReply)
	err := c.cc.Invoke(ctx, "/breez.Information/BreezAppVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *informationClient) ReceiverInfo(ctx context.Context, in *ReceiverInfoRequest, opts ...grpc.CallOption) (*ReceiverInfoReply, error) {
	out := new(ReceiverInfoReply)
	err := c.cc.Invoke(ctx, "/breez.Information/ReceiverInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InformationServer is the server API for Information service.
// All implementations must embed UnimplementedInformationServer
// for forward compatibility
type InformationServer interface {
	Ping(context.Context, *PingRequest) (*PingReply, error)
	Rates(context.Context, *RatesRequest) (*RatesReply, error)
	BreezAppVersions(context.Context, *BreezAppVersionsRequest) (*BreezAppVersionsReply, error)
	ReceiverInfo(context.Context, *ReceiverInfoRequest) (*ReceiverInfoReply, error)
	mustEmbedUnimplementedInformationServer()
}

// UnimplementedInformationServer must be embedded to have forward compatible implementations.
type UnimplementedInformationServer struct {
}

func (UnimplementedInformationServer) Ping(context.Context, *PingRequest) (*PingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedInformationServer) Rates(context.Context, *RatesRequest) (*RatesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rates not implemented")
}
func (UnimplementedInformationServer) BreezAppVersions(context.Context, *BreezAppVersionsRequest) (*BreezAppVersionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BreezAppVersions not implemented")
}
func (UnimplementedInformationServer) ReceiverInfo(context.Context, *ReceiverInfoRequest) (*ReceiverInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiverInfo not implemented")
}
func (UnimplementedInformationServer) mustEmbedUnimplementedInformationServer() {}

// UnsafeInformationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InformationServer will
// result in compilation errors.
type UnsafeInformationServer interface {
	mustEmbedUnimplementedInformationServer()
}

func RegisterInformationServer(s grpc.ServiceRegistrar, srv InformationServer) {
	s.RegisterService(&Information_ServiceDesc, srv)
}

func _Information_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InformationServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Information/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InformationServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Information_Rates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InformationServer).Rates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Information/Rates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InformationServer).Rates(ctx, req.(*RatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Information_BreezAppVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreezAppVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InformationServer).BreezAppVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Information/BreezAppVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InformationServer).BreezAppVersions(ctx, req.(*BreezAppVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Information_ReceiverInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiverInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InformationServer).ReceiverInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Information/ReceiverInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InformationServer).ReceiverInfo(ctx, req.(*ReceiverInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Information_ServiceDesc is the grpc.ServiceDesc for Information service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Information_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.Information",
	HandlerType: (*InformationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Information_Ping_Handler,
		},
		{
			MethodName: "Rates",
			Handler:    _Information_Rates_Handler,
		},
		{
			MethodName: "BreezAppVersions",
			Handler:    _Information_BreezAppVersions_Handler,
		},
		{
			MethodName: "ReceiverInfo",
			Handler:    _Information_ReceiverInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// ChannelOpenerClient is the client API for ChannelOpener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChannelOpenerClient interface {
	LSPList(ctx context.Context, in *LSPListRequest, opts ...grpc.CallOption) (*LSPListReply, error)
	OpenLSPChannel(ctx context.Context, in *OpenLSPChannelRequest, opts ...grpc.CallOption) (*OpenLSPChannelReply, error)
	RegisterPayment(ctx context.Context, in *RegisterPaymentRequest, opts ...grpc.CallOption) (*RegisterPaymentReply, error)
	CheckChannels(ctx context.Context, in *CheckChannelsRequest, opts ...grpc.CallOption) (*CheckChannelsReply, error)
}

type channelOpenerClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelOpenerClient(cc grpc.ClientConnInterface) ChannelOpenerClient {
	return &channelOpenerClient{cc}
}

func (c *channelOpenerClient) LSPList(ctx context.Context, in *LSPListRequest, opts ...grpc.CallOption) (*LSPListReply, error) {
	out := new(LSPListReply)
	err := c.cc.Invoke(ctx, "/breez.ChannelOpener/LSPList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelOpenerClient) OpenLSPChannel(ctx context.Context, in *OpenLSPChannelRequest, opts ...grpc.CallOption) (*OpenLSPChannelReply, error) {
	out := new(OpenLSPChannelReply)
	err := c.cc.Invoke(ctx, "/breez.ChannelOpener/OpenLSPChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelOpenerClient) RegisterPayment(ctx context.Context, in *RegisterPaymentRequest, opts ...grpc.CallOption) (*RegisterPaymentReply, error) {
	out := new(RegisterPaymentReply)
	err := c.cc.Invoke(ctx, "/breez.ChannelOpener/RegisterPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelOpenerClient) CheckChannels(ctx context.Context, in *CheckChannelsRequest, opts ...grpc.CallOption) (*CheckChannelsReply, error) {
	out := new(CheckChannelsReply)
	err := c.cc.Invoke(ctx, "/breez.ChannelOpener/CheckChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelOpenerServer is the server API for ChannelOpener service.
// All implementations must embed UnimplementedChannelOpenerServer
// for forward compatibility
type ChannelOpenerServer interface {
	LSPList(context.Context, *LSPListRequest) (*LSPListReply, error)
	OpenLSPChannel(context.Context, *OpenLSPChannelRequest) (*OpenLSPChannelReply, error)
	RegisterPayment(context.Context, *RegisterPaymentRequest) (*RegisterPaymentReply, error)
	CheckChannels(context.Context, *CheckChannelsRequest) (*CheckChannelsReply, error)
	mustEmbedUnimplementedChannelOpenerServer()
}

// UnimplementedChannelOpenerServer must be embedded to have forward compatible implementations.
type UnimplementedChannelOpenerServer struct {
}

func (UnimplementedChannelOpenerServer) LSPList(context.Context, *LSPListRequest) (*LSPListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LSPList not implemented")
}
func (UnimplementedChannelOpenerServer) OpenLSPChannel(context.Context, *OpenLSPChannelRequest) (*OpenLSPChannelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenLSPChannel not implemented")
}
func (UnimplementedChannelOpenerServer) RegisterPayment(context.Context, *RegisterPaymentRequest) (*RegisterPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPayment not implemented")
}
func (UnimplementedChannelOpenerServer) CheckChannels(context.Context, *CheckChannelsRequest) (*CheckChannelsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckChannels not implemented")
}
func (UnimplementedChannelOpenerServer) mustEmbedUnimplementedChannelOpenerServer() {}

// UnsafeChannelOpenerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelOpenerServer will
// result in compilation errors.
type UnsafeChannelOpenerServer interface {
	mustEmbedUnimplementedChannelOpenerServer()
}

func RegisterChannelOpenerServer(s grpc.ServiceRegistrar, srv ChannelOpenerServer) {
	s.RegisterService(&ChannelOpener_ServiceDesc, srv)
}

func _ChannelOpener_LSPList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LSPListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).LSPList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.ChannelOpener/LSPList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).LSPList(ctx, req.(*LSPListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelOpener_OpenLSPChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenLSPChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).OpenLSPChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.ChannelOpener/OpenLSPChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).OpenLSPChannel(ctx, req.(*OpenLSPChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelOpener_RegisterPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).RegisterPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.ChannelOpener/RegisterPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).RegisterPayment(ctx, req.(*RegisterPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelOpener_CheckChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelOpenerServer).CheckChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.ChannelOpener/CheckChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelOpenerServer).CheckChannels(ctx, req.(*CheckChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelOpener_ServiceDesc is the grpc.ServiceDesc for ChannelOpener service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelOpener_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.ChannelOpener",
	HandlerType: (*ChannelOpenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LSPList",
			Handler:    _ChannelOpener_LSPList_Handler,
		},
		{
			MethodName: "OpenLSPChannel",
			Handler:    _ChannelOpener_OpenLSPChannel_Handler,
		},
		{
			MethodName: "RegisterPayment",
			Handler:    _ChannelOpener_RegisterPayment_Handler,
		},
		{
			MethodName: "CheckChannels",
			Handler:    _ChannelOpener_CheckChannels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// PublicChannelOpenerClient is the client API for PublicChannelOpener service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicChannelOpenerClient interface {
	OpenPublicChannel(ctx context.Context, in *OpenPublicChannelRequest, opts ...grpc.CallOption) (*OpenPublicChannelReply, error)
}

type publicChannelOpenerClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicChannelOpenerClient(cc grpc.ClientConnInterface) PublicChannelOpenerClient {
	return &publicChannelOpenerClient{cc}
}

func (c *publicChannelOpenerClient) OpenPublicChannel(ctx context.Context, in *OpenPublicChannelRequest, opts ...grpc.CallOption) (*OpenPublicChannelReply, error) {
	out := new(OpenPublicChannelReply)
	err := c.cc.Invoke(ctx, "/breez.PublicChannelOpener/OpenPublicChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicChannelOpenerServer is the server API for PublicChannelOpener service.
// All implementations must embed UnimplementedPublicChannelOpenerServer
// for forward compatibility
type PublicChannelOpenerServer interface {
	OpenPublicChannel(context.Context, *OpenPublicChannelRequest) (*OpenPublicChannelReply, error)
	mustEmbedUnimplementedPublicChannelOpenerServer()
}

// UnimplementedPublicChannelOpenerServer must be embedded to have forward compatible implementations.
type UnimplementedPublicChannelOpenerServer struct {
}

func (UnimplementedPublicChannelOpenerServer) OpenPublicChannel(context.Context, *OpenPublicChannelRequest) (*OpenPublicChannelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenPublicChannel not implemented")
}
func (UnimplementedPublicChannelOpenerServer) mustEmbedUnimplementedPublicChannelOpenerServer() {}

// UnsafePublicChannelOpenerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicChannelOpenerServer will
// result in compilation errors.
type UnsafePublicChannelOpenerServer interface {
	mustEmbedUnimplementedPublicChannelOpenerServer()
}

func RegisterPublicChannelOpenerServer(s grpc.ServiceRegistrar, srv PublicChannelOpenerServer) {
	s.RegisterService(&PublicChannelOpener_ServiceDesc, srv)
}

func _PublicChannelOpener_OpenPublicChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenPublicChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicChannelOpenerServer).OpenPublicChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.PublicChannelOpener/OpenPublicChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicChannelOpenerServer).OpenPublicChannel(ctx, req.(*OpenPublicChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublicChannelOpener_ServiceDesc is the grpc.ServiceDesc for PublicChannelOpener service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublicChannelOpener_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.PublicChannelOpener",
	HandlerType: (*PublicChannelOpenerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenPublicChannel",
			Handler:    _PublicChannelOpener_OpenPublicChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// FundManagerClient is the client API for FundManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FundManagerClient interface {
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error)
	UpdateChannelPolicy(ctx context.Context, in *UpdateChannelPolicyRequest, opts ...grpc.CallOption) (*UpdateChannelPolicyReply, error)
	AddFundInit(ctx context.Context, in *AddFundInitRequest, opts ...grpc.CallOption) (*AddFundInitReply, error)
	AddFundStatus(ctx context.Context, in *AddFundStatusRequest, opts ...grpc.CallOption) (*AddFundStatusReply, error)
	RemoveFund(ctx context.Context, in *RemoveFundRequest, opts ...grpc.CallOption) (*RemoveFundReply, error)
	RedeemRemovedFunds(ctx context.Context, in *RedeemRemovedFundsRequest, opts ...grpc.CallOption) (*RedeemRemovedFundsReply, error)
	GetSwapPayment(ctx context.Context, in *GetSwapPaymentRequest, opts ...grpc.CallOption) (*GetSwapPaymentReply, error)
	RegisterTransactionConfirmation(ctx context.Context, in *RegisterTransactionConfirmationRequest, opts ...grpc.CallOption) (*RegisterTransactionConfirmationResponse, error)
}

type fundManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewFundManagerClient(cc grpc.ClientConnInterface) FundManagerClient {
	return &fundManagerClient{cc}
}

func (c *fundManagerClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error) {
	out := new(OpenChannelReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) UpdateChannelPolicy(ctx context.Context, in *UpdateChannelPolicyRequest, opts ...grpc.CallOption) (*UpdateChannelPolicyReply, error) {
	out := new(UpdateChannelPolicyReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/UpdateChannelPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) AddFundInit(ctx context.Context, in *AddFundInitRequest, opts ...grpc.CallOption) (*AddFundInitReply, error) {
	out := new(AddFundInitReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/AddFundInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) AddFundStatus(ctx context.Context, in *AddFundStatusRequest, opts ...grpc.CallOption) (*AddFundStatusReply, error) {
	out := new(AddFundStatusReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/AddFundStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) RemoveFund(ctx context.Context, in *RemoveFundRequest, opts ...grpc.CallOption) (*RemoveFundReply, error) {
	out := new(RemoveFundReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/RemoveFund", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) RedeemRemovedFunds(ctx context.Context, in *RedeemRemovedFundsRequest, opts ...grpc.CallOption) (*RedeemRemovedFundsReply, error) {
	out := new(RedeemRemovedFundsReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/RedeemRemovedFunds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) GetSwapPayment(ctx context.Context, in *GetSwapPaymentRequest, opts ...grpc.CallOption) (*GetSwapPaymentReply, error) {
	out := new(GetSwapPaymentReply)
	err := c.cc.Invoke(ctx, "/breez.FundManager/GetSwapPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fundManagerClient) RegisterTransactionConfirmation(ctx context.Context, in *RegisterTransactionConfirmationRequest, opts ...grpc.CallOption) (*RegisterTransactionConfirmationResponse, error) {
	out := new(RegisterTransactionConfirmationResponse)
	err := c.cc.Invoke(ctx, "/breez.FundManager/RegisterTransactionConfirmation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FundManagerServer is the server API for FundManager service.
// All implementations must embed UnimplementedFundManagerServer
// for forward compatibility
type FundManagerServer interface {
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error)
	UpdateChannelPolicy(context.Context, *UpdateChannelPolicyRequest) (*UpdateChannelPolicyReply, error)
	AddFundInit(context.Context, *AddFundInitRequest) (*AddFundInitReply, error)
	AddFundStatus(context.Context, *AddFundStatusRequest) (*AddFundStatusReply, error)
	RemoveFund(context.Context, *RemoveFundRequest) (*RemoveFundReply, error)
	RedeemRemovedFunds(context.Context, *RedeemRemovedFundsRequest) (*RedeemRemovedFundsReply, error)
	GetSwapPayment(context.Context, *GetSwapPaymentRequest) (*GetSwapPaymentReply, error)
	RegisterTransactionConfirmation(context.Context, *RegisterTransactionConfirmationRequest) (*RegisterTransactionConfirmationResponse, error)
	mustEmbedUnimplementedFundManagerServer()
}

// UnimplementedFundManagerServer must be embedded to have forward compatible implementations.
type UnimplementedFundManagerServer struct {
}

func (UnimplementedFundManagerServer) OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenChannel not implemented")
}
func (UnimplementedFundManagerServer) UpdateChannelPolicy(context.Context, *UpdateChannelPolicyRequest) (*UpdateChannelPolicyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChannelPolicy not implemented")
}
func (UnimplementedFundManagerServer) AddFundInit(context.Context, *AddFundInitRequest) (*AddFundInitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFundInit not implemented")
}
func (UnimplementedFundManagerServer) AddFundStatus(context.Context, *AddFundStatusRequest) (*AddFundStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFundStatus not implemented")
}
func (UnimplementedFundManagerServer) RemoveFund(context.Context, *RemoveFundRequest) (*RemoveFundReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFund not implemented")
}
func (UnimplementedFundManagerServer) RedeemRemovedFunds(context.Context, *RedeemRemovedFundsRequest) (*RedeemRemovedFundsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemRemovedFunds not implemented")
}
func (UnimplementedFundManagerServer) GetSwapPayment(context.Context, *GetSwapPaymentRequest) (*GetSwapPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSwapPayment not implemented")
}
func (UnimplementedFundManagerServer) RegisterTransactionConfirmation(context.Context, *RegisterTransactionConfirmationRequest) (*RegisterTransactionConfirmationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTransactionConfirmation not implemented")
}
func (UnimplementedFundManagerServer) mustEmbedUnimplementedFundManagerServer() {}

// UnsafeFundManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FundManagerServer will
// result in compilation errors.
type UnsafeFundManagerServer interface {
	mustEmbedUnimplementedFundManagerServer()
}

func RegisterFundManagerServer(s grpc.ServiceRegistrar, srv FundManagerServer) {
	s.RegisterService(&FundManager_ServiceDesc, srv)
}

func _FundManager_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_UpdateChannelPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChannelPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).UpdateChannelPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/UpdateChannelPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).UpdateChannelPolicy(ctx, req.(*UpdateChannelPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_AddFundInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFundInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).AddFundInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/AddFundInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).AddFundInit(ctx, req.(*AddFundInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_AddFundStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFundStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).AddFundStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/AddFundStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).AddFundStatus(ctx, req.(*AddFundStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_RemoveFund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).RemoveFund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/RemoveFund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).RemoveFund(ctx, req.(*RemoveFundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_RedeemRemovedFunds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedeemRemovedFundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).RedeemRemovedFunds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/RedeemRemovedFunds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).RedeemRemovedFunds(ctx, req.(*RedeemRemovedFundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_GetSwapPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSwapPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).GetSwapPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/GetSwapPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).GetSwapPayment(ctx, req.(*GetSwapPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FundManager_RegisterTransactionConfirmation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTransactionConfirmationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FundManagerServer).RegisterTransactionConfirmation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.FundManager/RegisterTransactionConfirmation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FundManagerServer).RegisterTransactionConfirmation(ctx, req.(*RegisterTransactionConfirmationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FundManager_ServiceDesc is the grpc.ServiceDesc for FundManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FundManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.FundManager",
	HandlerType: (*FundManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenChannel",
			Handler:    _FundManager_OpenChannel_Handler,
		},
		{
			MethodName: "UpdateChannelPolicy",
			Handler:    _FundManager_UpdateChannelPolicy_Handler,
		},
		{
			MethodName: "AddFundInit",
			Handler:    _FundManager_AddFundInit_Handler,
		},
		{
			MethodName: "AddFundStatus",
			Handler:    _FundManager_AddFundStatus_Handler,
		},
		{
			MethodName: "RemoveFund",
			Handler:    _FundManager_RemoveFund_Handler,
		},
		{
			MethodName: "RedeemRemovedFunds",
			Handler:    _FundManager_RedeemRemovedFunds_Handler,
		},
		{
			MethodName: "GetSwapPayment",
			Handler:    _FundManager_GetSwapPayment_Handler,
		},
		{
			MethodName: "RegisterTransactionConfirmation",
			Handler:    _FundManager_RegisterTransactionConfirmation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// SwapperClient is the client API for Swapper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SwapperClient interface {
	AddFundInit(ctx context.Context, in *AddFundInitRequest, opts ...grpc.CallOption) (*AddFundInitReply, error)
	AddFundStatus(ctx context.Context, in *AddFundStatusRequest, opts ...grpc.CallOption) (*AddFundStatusReply, error)
	GetSwapPayment(ctx context.Context, in *GetSwapPaymentRequest, opts ...grpc.CallOption) (*GetSwapPaymentReply, error)
	RedeemSwapPayment(ctx context.Context, in *RedeemSwapPaymentRequest, opts ...grpc.CallOption) (*RedeemSwapPaymentReply, error)
	GetReverseRoutingNode(ctx context.Context, in *GetReverseRoutingNodeRequest, opts ...grpc.CallOption) (*GetReverseRoutingNodeReply, error)
}

type swapperClient struct {
	cc grpc.ClientConnInterface
}

func NewSwapperClient(cc grpc.ClientConnInterface) SwapperClient {
	return &swapperClient{cc}
}

func (c *swapperClient) AddFundInit(ctx context.Context, in *AddFundInitRequest, opts ...grpc.CallOption) (*AddFundInitReply, error) {
	out := new(AddFundInitReply)
	err := c.cc.Invoke(ctx, "/breez.Swapper/AddFundInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapperClient) AddFundStatus(ctx context.Context, in *AddFundStatusRequest, opts ...grpc.CallOption) (*AddFundStatusReply, error) {
	out := new(AddFundStatusReply)
	err := c.cc.Invoke(ctx, "/breez.Swapper/AddFundStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapperClient) GetSwapPayment(ctx context.Context, in *GetSwapPaymentRequest, opts ...grpc.CallOption) (*GetSwapPaymentReply, error) {
	out := new(GetSwapPaymentReply)
	err := c.cc.Invoke(ctx, "/breez.Swapper/GetSwapPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapperClient) RedeemSwapPayment(ctx context.Context, in *RedeemSwapPaymentRequest, opts ...grpc.CallOption) (*RedeemSwapPaymentReply, error) {
	out := new(RedeemSwapPaymentReply)
	err := c.cc.Invoke(ctx, "/breez.Swapper/RedeemSwapPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapperClient) GetReverseRoutingNode(ctx context.Context, in *GetReverseRoutingNodeRequest, opts ...grpc.CallOption) (*GetReverseRoutingNodeReply, error) {
	out := new(GetReverseRoutingNodeReply)
	err := c.cc.Invoke(ctx, "/breez.Swapper/GetReverseRoutingNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapperServer is the server API for Swapper service.
// All implementations must embed UnimplementedSwapperServer
// for forward compatibility
type SwapperServer interface {
	AddFundInit(context.Context, *AddFundInitRequest) (*AddFundInitReply, error)
	AddFundStatus(context.Context, *AddFundStatusRequest) (*AddFundStatusReply, error)
	GetSwapPayment(context.Context, *GetSwapPaymentRequest) (*GetSwapPaymentReply, error)
	RedeemSwapPayment(context.Context, *RedeemSwapPaymentRequest) (*RedeemSwapPaymentReply, error)
	GetReverseRoutingNode(context.Context, *GetReverseRoutingNodeRequest) (*GetReverseRoutingNodeReply, error)
	mustEmbedUnimplementedSwapperServer()
}

// UnimplementedSwapperServer must be embedded to have forward compatible implementations.
type UnimplementedSwapperServer struct {
}

func (UnimplementedSwapperServer) AddFundInit(context.Context, *AddFundInitRequest) (*AddFundInitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFundInit not implemented")
}
func (UnimplementedSwapperServer) AddFundStatus(context.Context, *AddFundStatusRequest) (*AddFundStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFundStatus not implemented")
}
func (UnimplementedSwapperServer) GetSwapPayment(context.Context, *GetSwapPaymentRequest) (*GetSwapPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSwapPayment not implemented")
}
func (UnimplementedSwapperServer) RedeemSwapPayment(context.Context, *RedeemSwapPaymentRequest) (*RedeemSwapPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedeemSwapPayment not implemented")
}
func (UnimplementedSwapperServer) GetReverseRoutingNode(context.Context, *GetReverseRoutingNodeRequest) (*GetReverseRoutingNodeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReverseRoutingNode not implemented")
}
func (UnimplementedSwapperServer) mustEmbedUnimplementedSwapperServer() {}

// UnsafeSwapperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SwapperServer will
// result in compilation errors.
type UnsafeSwapperServer interface {
	mustEmbedUnimplementedSwapperServer()
}

func RegisterSwapperServer(s grpc.ServiceRegistrar, srv SwapperServer) {
	s.RegisterService(&Swapper_ServiceDesc, srv)
}

func _Swapper_AddFundInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFundInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapperServer).AddFundInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Swapper/AddFundInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapperServer).AddFundInit(ctx, req.(*AddFundInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapper_AddFundStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFundStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapperServer).AddFundStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Swapper/AddFundStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapperServer).AddFundStatus(ctx, req.(*AddFundStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapper_GetSwapPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSwapPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapperServer).GetSwapPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Swapper/GetSwapPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapperServer).GetSwapPayment(ctx, req.(*GetSwapPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapper_RedeemSwapPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedeemSwapPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapperServer).RedeemSwapPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Swapper/RedeemSwapPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapperServer).RedeemSwapPayment(ctx, req.(*RedeemSwapPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapper_GetReverseRoutingNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReverseRoutingNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapperServer).GetReverseRoutingNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.Swapper/GetReverseRoutingNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapperServer).GetReverseRoutingNode(ctx, req.(*GetReverseRoutingNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Swapper_ServiceDesc is the grpc.ServiceDesc for Swapper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Swapper_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.Swapper",
	HandlerType: (*SwapperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddFundInit",
			Handler:    _Swapper_AddFundInit_Handler,
		},
		{
			MethodName: "AddFundStatus",
			Handler:    _Swapper_AddFundStatus_Handler,
		},
		{
			MethodName: "GetSwapPayment",
			Handler:    _Swapper_GetSwapPayment_Handler,
		},
		{
			MethodName: "RedeemSwapPayment",
			Handler:    _Swapper_RedeemSwapPayment_Handler,
		},
		{
			MethodName: "GetReverseRoutingNode",
			Handler:    _Swapper_GetReverseRoutingNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// CTPClient is the client API for CTP service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CTPClient interface {
	JoinCTPSession(ctx context.Context, in *JoinCTPSessionRequest, opts ...grpc.CallOption) (*JoinCTPSessionResponse, error)
	TerminateCTPSession(ctx context.Context, in *TerminateCTPSessionRequest, opts ...grpc.CallOption) (*TerminateCTPSessionResponse, error)
}

type cTPClient struct {
	cc grpc.ClientConnInterface
}

func NewCTPClient(cc grpc.ClientConnInterface) CTPClient {
	return &cTPClient{cc}
}

func (c *cTPClient) JoinCTPSession(ctx context.Context, in *JoinCTPSessionRequest, opts ...grpc.CallOption) (*JoinCTPSessionResponse, error) {
	out := new(JoinCTPSessionResponse)
	err := c.cc.Invoke(ctx, "/breez.CTP/JoinCTPSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cTPClient) TerminateCTPSession(ctx context.Context, in *TerminateCTPSessionRequest, opts ...grpc.CallOption) (*TerminateCTPSessionResponse, error) {
	out := new(TerminateCTPSessionResponse)
	err := c.cc.Invoke(ctx, "/breez.CTP/TerminateCTPSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CTPServer is the server API for CTP service.
// All implementations must embed UnimplementedCTPServer
// for forward compatibility
type CTPServer interface {
	JoinCTPSession(context.Context, *JoinCTPSessionRequest) (*JoinCTPSessionResponse, error)
	TerminateCTPSession(context.Context, *TerminateCTPSessionRequest) (*TerminateCTPSessionResponse, error)
	mustEmbedUnimplementedCTPServer()
}

// UnimplementedCTPServer must be embedded to have forward compatible implementations.
type UnimplementedCTPServer struct {
}

func (UnimplementedCTPServer) JoinCTPSession(context.Context, *JoinCTPSessionRequest) (*JoinCTPSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinCTPSession not implemented")
}
func (UnimplementedCTPServer) TerminateCTPSession(context.Context, *TerminateCTPSessionRequest) (*TerminateCTPSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateCTPSession not implemented")
}
func (UnimplementedCTPServer) mustEmbedUnimplementedCTPServer() {}

// UnsafeCTPServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CTPServer will
// result in compilation errors.
type UnsafeCTPServer interface {
	mustEmbedUnimplementedCTPServer()
}

func RegisterCTPServer(s grpc.ServiceRegistrar, srv CTPServer) {
	s.RegisterService(&CTP_ServiceDesc, srv)
}

func _CTP_JoinCTPSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinCTPSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CTPServer).JoinCTPSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.CTP/JoinCTPSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CTPServer).JoinCTPSession(ctx, req.(*JoinCTPSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CTP_TerminateCTPSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminateCTPSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CTPServer).TerminateCTPSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.CTP/TerminateCTPSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CTPServer).TerminateCTPSession(ctx, req.(*TerminateCTPSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CTP_ServiceDesc is the grpc.ServiceDesc for CTP service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CTP_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.CTP",
	HandlerType: (*CTPServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "JoinCTPSession",
			Handler:    _CTP_JoinCTPSession_Handler,
		},
		{
			MethodName: "TerminateCTPSession",
			Handler:    _CTP_TerminateCTPSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// SyncNotifierClient is the client API for SyncNotifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncNotifierClient interface {
	RegisterPeriodicSync(ctx context.Context, in *RegisterPeriodicSyncRequest, opts ...grpc.CallOption) (*RegisterPeriodicSyncResponse, error)
}

type syncNotifierClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncNotifierClient(cc grpc.ClientConnInterface) SyncNotifierClient {
	return &syncNotifierClient{cc}
}

func (c *syncNotifierClient) RegisterPeriodicSync(ctx context.Context, in *RegisterPeriodicSyncRequest, opts ...grpc.CallOption) (*RegisterPeriodicSyncResponse, error) {
	out := new(RegisterPeriodicSyncResponse)
	err := c.cc.Invoke(ctx, "/breez.SyncNotifier/RegisterPeriodicSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncNotifierServer is the server API for SyncNotifier service.
// All implementations must embed UnimplementedSyncNotifierServer
// for forward compatibility
type SyncNotifierServer interface {
	RegisterPeriodicSync(context.Context, *RegisterPeriodicSyncRequest) (*RegisterPeriodicSyncResponse, error)
	mustEmbedUnimplementedSyncNotifierServer()
}

// UnimplementedSyncNotifierServer must be embedded to have forward compatible implementations.
type UnimplementedSyncNotifierServer struct {
}

func (UnimplementedSyncNotifierServer) RegisterPeriodicSync(context.Context, *RegisterPeriodicSyncRequest) (*RegisterPeriodicSyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPeriodicSync not implemented")
}
func (UnimplementedSyncNotifierServer) mustEmbedUnimplementedSyncNotifierServer() {}

// UnsafeSyncNotifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncNotifierServer will
// result in compilation errors.
type UnsafeSyncNotifierServer interface {
	mustEmbedUnimplementedSyncNotifierServer()
}

func RegisterSyncNotifierServer(s grpc.ServiceRegistrar, srv SyncNotifierServer) {
	s.RegisterService(&SyncNotifier_ServiceDesc, srv)
}

func _SyncNotifier_RegisterPeriodicSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPeriodicSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncNotifierServer).RegisterPeriodicSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.SyncNotifier/RegisterPeriodicSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncNotifierServer).RegisterPeriodicSync(ctx, req.(*RegisterPeriodicSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SyncNotifier_ServiceDesc is the grpc.ServiceDesc for SyncNotifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SyncNotifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.SyncNotifier",
	HandlerType: (*SyncNotifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterPeriodicSync",
			Handler:    _SyncNotifier_RegisterPeriodicSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// PushTxNotifierClient is the client API for PushTxNotifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PushTxNotifierClient interface {
	RegisterTxNotification(ctx context.Context, in *PushTxNotificationRequest, opts ...grpc.CallOption) (*PushTxNotificationResponse, error)
}

type pushTxNotifierClient struct {
	cc grpc.ClientConnInterface
}

func NewPushTxNotifierClient(cc grpc.ClientConnInterface) PushTxNotifierClient {
	return &pushTxNotifierClient{cc}
}

func (c *pushTxNotifierClient) RegisterTxNotification(ctx context.Context, in *PushTxNotificationRequest, opts ...grpc.CallOption) (*PushTxNotificationResponse, error) {
	out := new(PushTxNotificationResponse)
	err := c.cc.Invoke(ctx, "/breez.PushTxNotifier/RegisterTxNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PushTxNotifierServer is the server API for PushTxNotifier service.
// All implementations must embed UnimplementedPushTxNotifierServer
// for forward compatibility
type PushTxNotifierServer interface {
	RegisterTxNotification(context.Context, *PushTxNotificationRequest) (*PushTxNotificationResponse, error)
	mustEmbedUnimplementedPushTxNotifierServer()
}

// UnimplementedPushTxNotifierServer must be embedded to have forward compatible implementations.
type UnimplementedPushTxNotifierServer struct {
}

func (UnimplementedPushTxNotifierServer) RegisterTxNotification(context.Context, *PushTxNotificationRequest) (*PushTxNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTxNotification not implemented")
}
func (UnimplementedPushTxNotifierServer) mustEmbedUnimplementedPushTxNotifierServer() {}

// UnsafePushTxNotifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PushTxNotifierServer will
// result in compilation errors.
type UnsafePushTxNotifierServer interface {
	mustEmbedUnimplementedPushTxNotifierServer()
}

func RegisterPushTxNotifierServer(s grpc.ServiceRegistrar, srv PushTxNotifierServer) {
	s.RegisterService(&PushTxNotifier_ServiceDesc, srv)
}

func _PushTxNotifier_RegisterTxNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushTxNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PushTxNotifierServer).RegisterTxNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.PushTxNotifier/RegisterTxNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PushTxNotifierServer).RegisterTxNotification(ctx, req.(*PushTxNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PushTxNotifier_ServiceDesc is the grpc.ServiceDesc for PushTxNotifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PushTxNotifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.PushTxNotifier",
	HandlerType: (*PushTxNotifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterTxNotification",
			Handler:    _PushTxNotifier_RegisterTxNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}

// InactiveNotifierClient is the client API for InactiveNotifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InactiveNotifierClient interface {
	InactiveNotify(ctx context.Context, in *InactiveNotifyRequest, opts ...grpc.CallOption) (*InactiveNotifyResponse, error)
}

type inactiveNotifierClient struct {
	cc grpc.ClientConnInterface
}

func NewInactiveNotifierClient(cc grpc.ClientConnInterface) InactiveNotifierClient {
	return &inactiveNotifierClient{cc}
}

func (c *inactiveNotifierClient) InactiveNotify(ctx context.Context, in *InactiveNotifyRequest, opts ...grpc.CallOption) (*InactiveNotifyResponse, error) {
	out := new(InactiveNotifyResponse)
	err := c.cc.Invoke(ctx, "/breez.InactiveNotifier/InactiveNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InactiveNotifierServer is the server API for InactiveNotifier service.
// All implementations must embed UnimplementedInactiveNotifierServer
// for forward compatibility
type InactiveNotifierServer interface {
	InactiveNotify(context.Context, *InactiveNotifyRequest) (*InactiveNotifyResponse, error)
	mustEmbedUnimplementedInactiveNotifierServer()
}

// UnimplementedInactiveNotifierServer must be embedded to have forward compatible implementations.
type UnimplementedInactiveNotifierServer struct {
}

func (UnimplementedInactiveNotifierServer) InactiveNotify(context.Context, *InactiveNotifyRequest) (*InactiveNotifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InactiveNotify not implemented")
}
func (UnimplementedInactiveNotifierServer) mustEmbedUnimplementedInactiveNotifierServer() {}

// UnsafeInactiveNotifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InactiveNotifierServer will
// result in compilation errors.
type UnsafeInactiveNotifierServer interface {
	mustEmbedUnimplementedInactiveNotifierServer()
}

func RegisterInactiveNotifierServer(s grpc.ServiceRegistrar, srv InactiveNotifierServer) {
	s.RegisterService(&InactiveNotifier_ServiceDesc, srv)
}

func _InactiveNotifier_InactiveNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InactiveNotifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InactiveNotifierServer).InactiveNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/breez.InactiveNotifier/InactiveNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InactiveNotifierServer).InactiveNotify(ctx, req.(*InactiveNotifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InactiveNotifier_ServiceDesc is the grpc.ServiceDesc for InactiveNotifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InactiveNotifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "breez.InactiveNotifier",
	HandlerType: (*InactiveNotifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InactiveNotify",
			Handler:    _InactiveNotifier_InactiveNotify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "breez.proto",
}
